"use client";

import { useState, useRef, useEffect, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Download,
  Copy,
  Check,
  ExternalLink,
  ChevronDown,
  FileCode,
  FolderDown,
  Zap,
} from "lucide-react";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import sdk from "@stackblitz/sdk";
import { generateProject, getStackBlitzTemplate } from "@/lib/exportProjects";

interface ExportDropdownProps {
  code: string;
  framework: string;
  id: string;
  onToast: (message: string, type?: "success" | "error") => void;
}

export default function ExportDropdown({ code, framework, id, onToast }: ExportDropdownProps) {
  const [open, setOpen] = useState(false);
  const [copied, setCopied] = useState(false);
  const ref = useRef<HTMLDivElement>(null);
  const timerRef = useRef<ReturnType<typeof setTimeout>>(undefined);

  // Clear timeout on unmount
  useEffect(() => {
    return () => {
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, []);

  // Click outside to close
  useEffect(() => {
    if (!open) return;
    const handler = (e: MouseEvent) => {
      if (ref.current && !ref.current.contains(e.target as Node)) setOpen(false);
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, [open]);

  // Escape to close
  useEffect(() => {
    if (!open) return;
    const handler = (e: KeyboardEvent) => {
      if (e.key === "Escape") setOpen(false);
    };
    document.addEventListener("keydown", handler);
    return () => document.removeEventListener("keydown", handler);
  }, [open]);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopied(true);
      onToast("Code copied!");
      timerRef.current = setTimeout(() => setCopied(false), 2000);
    } catch {
      onToast("Failed to copy code", "error");
    }
    setOpen(false);
  };

  const handleZip = async () => {
    const files = generateProject(code, framework);
    const zip = new JSZip();
    for (const [path, content] of Object.entries(files)) {
      zip.file(path, content);
    }
    const blob = await zip.generateAsync({ type: "blob" });
    saveAs(blob, `snapcode-${id}.zip`);
    onToast("Project ZIP downloaded!");
    setOpen(false);
  };

  const handleCodeSandbox = () => {
    try {
      const files = generateProject(code, framework);
      const csFiles: Record<string, { content: string; isBinary: false }> = {};
      for (const [path, content] of Object.entries(files)) {
        csFiles[path] = { content, isBinary: false };
      }
      const form = document.createElement("form");
      form.method = "POST";
      form.target = "_blank";
      form.action = "https://codesandbox.io/api/v1/sandboxes/define";
      const input = document.createElement("input");
      input.type = "hidden";
      input.name = "parameters";
      const jsonStr = JSON.stringify({ files: csFiles });
      input.value = btoa(Array.from(new TextEncoder().encode(jsonStr), (b) => String.fromCharCode(b)).join(""));
      form.appendChild(input);
      document.body.appendChild(form);
      form.submit();
      document.body.removeChild(form);
      onToast("Opening in CodeSandbox...");
    } catch (err) {
      console.error("[ExportDropdown] CodeSandbox error:", err);
      onToast("Failed to open CodeSandbox", "error");
    }
    setOpen(false);
  };

  const handleStackBlitz = () => {
    const files = generateProject(code, framework);
    const template = getStackBlitzTemplate(framework);
    sdk.openProject(
      {
        title: `SnapCode Export â€” ${framework}`,
        description: "Generated by SnapCode",
        template,
        files,
      },
      { openFile: Object.keys(files).find((f) => f.includes("App") || f.includes("index.html")) || Object.keys(files)[0] }
    );
    onToast("Opening in StackBlitz...");
    setOpen(false);
  };

  const handleCopyHtml = async () => {
    try {
      // Dynamic import to avoid pulling ResponsivePreview's build functions into the bundle
      const { buildPreviewHtml } = await import("@/lib/buildPreviewHtml");
      const html = buildPreviewHtml(code, framework);
      await navigator.clipboard.writeText(html);
      onToast("HTML copied!");
    } catch {
      onToast("Failed to copy HTML", "error");
    }
    setOpen(false);
  };

  const items = [
    { label: copied ? "Copied!" : "Copy Code", icon: copied ? Check : Copy, action: handleCopy, accent: copied },
    { label: "Download ZIP", icon: FolderDown, action: handleZip },
    { label: "CodeSandbox", icon: ExternalLink, action: handleCodeSandbox },
    { label: "StackBlitz", icon: Zap, action: handleStackBlitz },
    { label: "Copy as HTML", icon: FileCode, action: handleCopyHtml },
  ];

  return (
    <div ref={ref} className="relative">
      <button
        onClick={() => setOpen((v) => !v)}
        className="flex items-center gap-1.5 min-w-[44px] min-h-[44px] px-3 sm:px-4 py-2 bg-[#18181b] hover:bg-[#27272a] text-gray-300 hover:text-white shrink-0 justify-center btn-v6-secondary transition-colors duration-150"
        aria-label="Export options"
        aria-haspopup="menu"
        aria-expanded={open}
      >
        <Download className="w-3.5 h-3.5" />
        <span className="hidden sm:inline text-xs">Export</span>
        <ChevronDown className={`w-3 h-3 transition-transform duration-150 ${open ? "rotate-180" : ""}`} />
      </button>

      <AnimatePresence>
        {open && (
          <motion.div
            initial={{ opacity: 0, y: -4, scale: 0.97 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -4, scale: 0.97 }}
            transition={{ duration: 0.12 }}
            role="menu"
            className="absolute right-0 top-full mt-1.5 w-48 max-w-[calc(100vw-2rem)] bg-[#111] border border-[#27272a] rounded-xl overflow-hidden shadow-xl shadow-black/40 z-50"
          >
            {items.map((item) => (
              <button
                key={item.label}
                role="menuitem"
                onClick={item.action}
                className={`w-full flex items-center gap-2.5 px-3.5 py-3 min-h-[44px] text-xs transition-colors duration-100 ${
                  item.accent
                    ? "text-[#a855f7] bg-[#a855f7]/5"
                    : "text-gray-400 hover:text-white hover:bg-[#1a1a1a]"
                }`}
              >
                <item.icon className="w-3.5 h-3.5 shrink-0" />
                {item.label}
              </button>
            ))}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
