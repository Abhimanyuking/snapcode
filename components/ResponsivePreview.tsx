"use client";

import { useState, useEffect, useRef, useMemo } from "react";
import { Monitor, Tablet, Smartphone, Maximize2, Minimize2 } from "lucide-react";

interface ResponsivePreviewProps {
  code: string;
  framework: string;
}

const viewports = [
  { id: "desktop", icon: Monitor, width: "100%", label: "Desktop" },
  { id: "tablet", icon: Tablet, width: "768px", label: "Tablet" },
  { id: "mobile", icon: Smartphone, width: "375px", label: "Mobile" },
] as const;

/**
 * Clean React/Next.js code for browser rendering
 */
function cleanReactCode(code: string): string {
  let cleaned = code;

  // Remove SnapCode watermark comment
  cleaned = cleaned.replace(/<!--\s*Generated by SnapCode\.ai\s*-->\s*/g, "");

  // Remove 'use client' / 'use server' directives
  cleaned = cleaned.replace(/['"]use (client|server)['"];?\s*/g, "");

  // Remove TypeScript type-only imports: import type { ... } from '...'
  cleaned = cleaned.replace(/^import\s+type\s+\{[^}]*\}\s+from\s+['"][^'"]*['"];?\s*$/gm, "");

  // Collect named imports from 'react' (handles both `import { ... }` and `import React, { ... }`)
  const reactImportMatch = cleaned.match(
    /import\s+(?:React\s*,\s*)?\{([^}]+)\}\s+from\s+['"]react['"];?/
  );
  let destructured = "";
  if (reactImportMatch) {
    const names = reactImportMatch[1]
      .split(",")
      .map((n) => n.trim())
      .filter((n) => n && !n.startsWith("type "));
    if (names.length > 0) {
      destructured = `const { ${names.join(", ")} } = React;\n`;
    }
  }

  // Remove all import statements
  cleaned = cleaned.replace(/^import\s+.*?from\s+['"].*?['"];?\s*$/gm, "");
  cleaned = cleaned.replace(/^import\s+['"].*?['"];?\s*$/gm, "");

  // Remove TypeScript interfaces and type aliases
  cleaned = cleaned.replace(/^(export\s+)?(interface|type)\s+\w[\s\S]*?^\}/gm, "");
  cleaned = cleaned.replace(/^type\s+\w+\s*=\s*[^;]+;?\s*$/gm, "");

  // Remove all export keywords (default, named, re-exports)
  cleaned = cleaned.replace(/export\s+default\s+/g, "");
  cleaned = cleaned.replace(/export\s+/g, "");
  cleaned = cleaned.replace(/^export\s*\{[^}]*\};?\s*$/gm, "");

  // Add React hooks destructuring at top
  cleaned = destructured + cleaned;

  return cleaned.trim();
}

/**
 * Build HTML page for React/Next.js with Babel Standalone + TypeScript
 */
function buildReactHtml(code: string): string {
  const cleaned = cleanReactCode(code);
  // Escape </script> in user code to prevent premature tag closing
  const safeCode = cleaned.replace(/<\/script/gi, "<\\/script");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, sans-serif; }
    * { box-sizing: border-box; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // Next.js shims — provide stubs for common Next.js components
    window.Link = function Link(props) {
      return React.createElement('a', {
        href: props.href || '#',
        className: props.className || '',
        style: props.style,
        onClick: function(e) { e.preventDefault(); }
      }, props.children);
    };
    function ImageComponent(props) {
      return React.createElement('img', {
        src: props.src || 'https://placehold.co/' + (props.width || 400) + 'x' + (props.height || 300),
        alt: props.alt || '',
        width: props.width,
        height: props.height,
        className: props.className || '',
        style: props.style
      });
    }
    // Stub for lucide-react icons — render as empty inline SVG placeholders
    window.LucideIcon = function(props) {
      return React.createElement('span', {
        className: props.className || 'w-5 h-5 inline-block',
        style: { display: 'inline-block', width: '1em', height: '1em' }
      });
    };
  </script>
  <script type="text/babel" data-presets="react,typescript">
    ${safeCode}

    // Auto-detect component and render
    (function() {
      var __names = [
        typeof App !== 'undefined' && App,
        typeof Home !== 'undefined' && Home,
        typeof Page !== 'undefined' && Page,
        typeof Main !== 'undefined' && Main,
        typeof Component !== 'undefined' && Component,
        typeof Index !== 'undefined' && Index,
        typeof Layout !== 'undefined' && Layout,
        typeof Hero !== 'undefined' && Hero,
        typeof Card !== 'undefined' && Card,
        typeof Landing !== 'undefined' && Landing,
        typeof Dashboard !== 'undefined' && Dashboard,
        typeof Header !== 'undefined' && Header,
        typeof Footer !== 'undefined' && Footer,
        typeof Navbar !== 'undefined' && Navbar,
        typeof Sidebar !== 'undefined' && Sidebar,
        typeof Form !== 'undefined' && Form,
        typeof Login !== 'undefined' && Login,
        typeof Signup !== 'undefined' && Signup,
        typeof Profile !== 'undefined' && Profile,
        typeof Settings !== 'undefined' && Settings,
      ];
      var __Component = __names.find(function(c) { return c && typeof c === 'function'; });
      if (__Component) {
        ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(__Component));
      } else {
        document.getElementById('root').innerHTML = '<div style="padding:20px;color:#888;text-align:center;">No component found to render.</div>';
      }
    })();
  </script>
</body>
</html>`;
}

/**
 * Extract template and style from Vue SFC code
 */
function buildVueHtml(code: string): string {
  let clean = code.replace(/<!--\s*Generated by SnapCode\.ai\s*-->\s*/g, "");

  const templateMatch = clean.match(/<template>([\s\S]*?)<\/template>/);
  const styleMatch = clean.match(/<style[^>]*>([\s\S]*?)<\/style>/);

  const template = templateMatch ? templateMatch[1].trim() : clean
    .replace(/<script[\s\S]*?<\/script>/g, "")
    .replace(/<style[\s\S]*?<\/style>/g, "")
    .trim();

  const styles = styleMatch ? styleMatch[1] : "";

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <style>body{margin:0;font-family:system-ui,sans-serif}${styles}</style>
</head>
<body>
  <div id="app">${template}</div>
  <script>
    try {
      var app = Vue.createApp({ data: function() { return {}; } });
      app.mount('#app');
    } catch(e) {
      console.error('Vue mount error:', e);
    }
  </script>
</body>
</html>`;
}

/**
 * Extract HTML from Svelte component code
 */
function buildSvelteHtml(code: string): string {
  let clean = code.replace(/<!--\s*Generated by SnapCode\.ai\s*-->\s*/g, "");

  const styleMatch = clean.match(/<style[^>]*>([\s\S]*?)<\/style>/);
  const styles = styleMatch ? styleMatch[1] : "";

  let html = clean
    .replace(/<script[\s\S]*?<\/script>/g, "")
    .replace(/<style[\s\S]*?<\/style>/g, "");

  // Remove Svelte-specific syntax
  html = html.replace(/\{#[^}]+\}/g, "");
  html = html.replace(/\{:[^}]+\}/g, "");
  html = html.replace(/\{\/[^}]+\}/g, "");
  html = html.replace(/on:[a-z]+=\{[^}]*\}/g, "");
  html = html.replace(/bind:[a-z]+=\{[^}]*\}/g, "");
  html = html.replace(/\{([^}]+)\}/g, "$1");

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>body{margin:0;font-family:system-ui,sans-serif}${styles}</style>
</head>
<body>${html.trim()}</body>
</html>`;
}

/**
 * Build HTML for plain HTML + Tailwind
 */
function buildHtmlTailwind(code: string): string {
  let clean = code.replace(/<!--\s*Generated by SnapCode\.ai\s*-->\s*/g, "");

  if (clean.toLowerCase().includes("<!doctype") || clean.toLowerCase().includes("<html")) {
    if (!clean.includes("tailwindcss")) {
      clean = clean.replace("</head>", `<script src="https://cdn.tailwindcss.com"></script>\n</head>`);
    }
    return clean;
  }

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>body{margin:0;font-family:system-ui,sans-serif}</style>
</head>
<body>${clean}</body>
</html>`;
}

/**
 * Build HTML for Bootstrap
 */
function buildBootstrapHtml(code: string): string {
  let clean = code.replace(/<!--\s*Generated by SnapCode\.ai\s*-->\s*/g, "");

  // Full HTML document
  if (clean.toLowerCase().includes("<!doctype") || clean.toLowerCase().includes("<html")) {
    // Inject Bootstrap CDN if not already present
    if (!clean.toLowerCase().includes("bootstrap")) {
      clean = clean.replace(
        /<\/head>/i,
        `<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">\n<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>\n</head>`
      );
    }
    // Ensure viewport meta exists
    if (!clean.includes("viewport")) {
      clean = clean.replace(
        /<head>/i,
        `<head>\n<meta name="viewport" content="width=device-width, initial-scale=1.0">`
      );
    }
    return clean;
  }

  // Partial HTML — wrap with full Bootstrap template
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>body{margin:0;font-family:system-ui,sans-serif}</style>
</head>
<body>${clean}</body>
</html>`;
}

/**
 * Build HTML content based on framework
 */
function buildPreviewHtml(code: string, framework: string): string {
  switch (framework) {
    case "react-tailwind":
    case "nextjs":
      return buildReactHtml(code);
    case "vue":
      return buildVueHtml(code);
    case "svelte":
      return buildSvelteHtml(code);
    case "bootstrap":
      return buildBootstrapHtml(code);
    default:
      return buildHtmlTailwind(code);
  }
}

export default function ResponsivePreview({ code, framework }: ResponsivePreviewProps) {
  const [viewport, setViewport] = useState<"desktop" | "tablet" | "mobile">("desktop");
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const check = () => setIsMobile(window.innerWidth < 1024);
    check();
    window.addEventListener("resize", check);
    return () => window.removeEventListener("resize", check);
  }, []);

  // Build HTML content using srcdoc approach (more reliable than doc.write)
  const htmlContent = useMemo(() => {
    if (!code) return "";
    return buildPreviewHtml(code, framework);
  }, [code, framework]);

  const toggleFullscreen = () => {
    if (!isFullscreen && containerRef.current) {
      containerRef.current.requestFullscreen?.();
    } else {
      document.exitFullscreen?.();
    }
  };

  useEffect(() => {
    const handler = () => setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener("fullscreenchange", handler);
    return () => document.removeEventListener("fullscreenchange", handler);
  }, []);

  const currentViewport = viewports.find((v) => v.id === viewport) ?? viewports[0];

  return (
    <div ref={containerRef} className="flex flex-col h-full bg-[#000000]">
      {/* Toolbar — hidden on mobile, shown on lg+ */}
      <div className="relative hidden lg:flex items-center justify-between px-4 py-2 bg-[#0a0a0a] border-b border-[#27272a]">
        <div className="flex items-center gap-1" role="group" aria-label="Viewport size">
          {viewports.map((vp) => (
            <button
              key={vp.id}
              onClick={() => setViewport(vp.id)}
              className={`flex items-center gap-2 px-3.5 py-2 min-h-[44px] text-xs transition-all btn-v6-ghost btn-text-sm ${
                viewport === vp.id
                  ? "bg-gradient-to-r from-[#a855f7]/20 to-[#ec4899]/15 text-[#a855f7] shadow-sm shadow-[#a855f7]/10"
                  : "text-gray-500 hover:text-gray-300 hover:bg-[#18181b]"
              }`}
              aria-label={`${vp.label} view`}
              title={vp.label}
            >
              <vp.icon className="w-3.5 h-3.5" aria-hidden="true" />
              <span>{vp.label}</span>
            </button>
          ))}
        </div>

        <div className="flex items-center gap-2">
          <span className="text-xs text-gray-500">{currentViewport.width}</span>
          <button
            onClick={toggleFullscreen}
            aria-label={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
            className="p-2 min-h-[44px] min-w-[44px] flex items-center justify-center text-gray-500 hover:text-white hover:bg-[#18181b] btn-v6-icon"
          >
            {isFullscreen ? <Minimize2 className="w-3.5 h-3.5" /> : <Maximize2 className="w-3.5 h-3.5" />}
          </button>
        </div>

        <div className="absolute bottom-0 left-0 right-0 h-[1px] bg-gradient-to-r from-transparent via-[#a855f7]/40 to-transparent" />
      </div>

      {/* Preview — full width on mobile, respects viewport on desktop */}
      <div className={`flex-1 flex items-start justify-center overflow-auto bg-[#000000] ${viewport === "desktop" || isMobile ? "p-0" : "p-4"}`}>
        <div
          className={`bg-white overflow-hidden transition-all duration-300 ${viewport !== "desktop" && !isMobile ? "rounded-lg shadow-2xl shadow-black/50" : ""}`}
          style={{
            width: isMobile ? "100%" : currentViewport.width,
            maxWidth: "100%",
            height: isFullscreen ? "calc(100vh - 48px)" : "100%",
          }}
        >
          <iframe
            title="Preview"
            className="w-full h-full border-0"
            sandbox="allow-scripts"
            srcDoc={htmlContent}
          />
        </div>
      </div>
    </div>
  );
}
